<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>前端组件开发心得</title>
        <link rel="stylesheet" href="./static/tomorrow.css">
        <link rel="stylesheet" href="./static/doc.css">
        <script src="//unpkg.com/vue@2.3.3"></script>
        <style>
.module-css .rule-1 .rule-demo .box {
  display: inline-block;
  margin: 0;
  width: 40px;
  height: 40px;
  border: 1px solid #228ae6;
  background: #4dadf7;
}
.module-css .rule-1 .rule-demo .box {
  margin-right: 10px;
}
.module-css .rule-2 .box {
  display: inline-block;
  margin: 0;
  padding: 5px;
}
.module-css .rule-2 .box::after {
  content: '';
  display: block;
  width: 40px;
  height: 40px;
  background: #4dadf7;
  border: 1px solid #228ae6;
}
.module-css .rule-2 .box:hover::after {
  background: #228ae6;
}
.module-css .rule-2 .box {
  margin-right: 0px;
}
.module-css .rule-3 .rule-demo .box {
  display: inline-block;
  margin: 0;
  width: 50px;
  height: 50px;
  padding: 10px;
  vertical-align: middle;
  text-align: center;
  border: 1px solid #228ae6;
  background: #4dadf7;
  box-sizing: border-box;
}
.module-css .rule-3 .rule-demo .box {
  width: 200px;
  height: 200px;
}
.x-button {
  display: inline-block;
  margin: 0;
  padding: 9px 0;
  width: 80px;
  height: 40px;
  line-height: 20px;
  font-size: 14px;
  vertical-align: middle;
  text-align: center;
  color: #c92a2a;
  cursor: pointer;
  border: 1px solid currentColor;
  background: transparent;
  box-sizing: border-box;
}
.x-button svg {
  color: inherit;
  fill: currentColor;
  width: 16px;
  height: 16px;
  display: inline-block;
  vertical-align: -3px;
}
.module-css .rule-5 .x-button {
  color: #4dadf7;
}
.module-css .rule-5 .x-button:hover {
  color: #228ae6;
}
.x-input {
  display: inline-block;
  margin: 0;
  padding: 0 10px;
  width: 400px;
  height: 40px;
  line-height: 40px;
  vertical-align: middle;
  text-align: center;
  color: #495057;
  border: 2px solid currentColor;
  background: #FFF;
  box-sizing: border-box;
}
.x-input svg {
  margin: 8px 0 0 -30px;
  float: left;
  width: 20px;
  height: 20px;
  fill: currentColor;
  color: inherit;
}
.x-input--search {
  padding-left: 40px;
}
.x-input__txt {
  display: block;
  width: 100%;
  height: 100%;
  padding: 0;
  border: 0;
  font-size: 20px;
  color: inherit;
  outline: none;
}
.module-css .rule-6 .x-input {
  width: 300px;
}
</style>
    </head>
    <body class="page-rules">
        
        <div class="main">
            <div class="header">
                <h1>前端组件开发心得</h1>
                <div class="header-info">
                    <p>这篇文档总结了一些前端组件的开发心得，整理出了一个我们理想中的Best Practise。</p>
                    <p>它更多的是Vue相关的内容，如果你有其他库（React，Angular）的心得也可以发Merge Request来提交。</p>
                    <p>希望会对你的组件库开发有一定帮助。</p>
                </div>
            </div><div class="module module-css"><h2 id="">样式篇</h2>
<h3 id="-2">组件大小所见即所得</h3>
<div class="rule rule-1">
                        <div class="rule-right">
                        <div class="rule-txt"><p>一般情况下，<strong>组件所能看到的大小即是它的真实大小</strong>。尽量不要在组件上使用看不见的边界，例如在外部加入<code>margin</code>样式。</p>
<p>这样做的好处是：从设计师的角度出发去设计你的代码，设计师给到的标注稿的间距标注一般不会考虑组件外部的透明边界。而组件的使用者（其他开发同学）可能不知道这样的边界的存在，就会造成一些返工。</p>
<p>所以为了提高组件的易用性，一般推荐组件所能看到的大小即是它的真实大小。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="undefined">
.module-css .rule-1 {
    // 组件样式
    .rule-demo .box {
        display: inline-block;
        margin: 0;
        width: 40px;
        height: 40px;
        border: 1px solid #228ae6;
        background: #4dadf7;
    }

    // 使用组件时候的样式
    .rule-demo .box {
        margin-right: 10px;
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _vm._m(0);
                },
                staticRenderFns: [function () {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "box"
                    }), _vm._v(" "), _c('span', {
                        staticClass: "box"
                    }), _vm._v(" "), _c('span', {
                        staticClass: "box"
                    })]);
                }]
            };return options;
        }();
        var Component = function () {
            return {};
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<div class="rule rule-2">
                        <div class="rule-right">
                        <div class="rule-txt"><p>当然也会存在一些例外情况，比如说组件的鼠标响应区域比组件的实际展示区域要大。</p>
<p>这时候我们推荐和设计师做好充分地沟通，确认设计稿中的标注要考虑到这些隐藏边界，或者设计师根本不关心这些隐藏边界导致的几像素偏差。以简化组件使用者在使用此组件时候的难度。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="undefined">
.module-css .rule-2 {
    // 组件样式
    .box {
        display: inline-block;
        margin: 0;
        padding: 5px;
    }
    .box::after {
        content: '';
        display: block;
        width: 40px;
        height: 40px;
        background: #4dadf7;
        border: 1px solid #228ae6;
    }
    .box:hover::after {
        background: #228ae6;
    }
    // 使用组件时候的样式
    .box {
        margin-right: 10px - 5px * 2;
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _vm._m(0);
                },
                staticRenderFns: [function () {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "box"
                    }), _vm._v(" "), _c('span', {
                        staticClass: "box"
                    }), _vm._v(" "), _c('span', {
                        staticClass: "box"
                    })]);
                }]
            };return options;
        }();
        var Component = function () {
            return {};
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="box-sizing">使用<code>box-sizing</code></h3>
<div class="rule rule-3">
                        <div class="rule-right">
                        <div class="rule-txt"><p>组件的根节点样式优先使用<code>box-sizing:border-box;</code>，这样在组件外部就可以轻松控制组件的宽高。不需要考虑根节点的<code>border</code>和<code>padding</code>值。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>200x200<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="undefined">
.module-css .rule-3 {
    // 组件样式
    .rule-demo .box {
        display: inline-block;
        margin: 0;
        width: 50px;
        height: 50px;
        padding: 10px;
        vertical-align: middle;
        text-align: center;
        border: 1px solid #228ae6;
        background: #4dadf7;
        box-sizing: border-box;
    }

    // 使用组件时候的样式
    .rule-demo .box {
        width: 200px;
        height: 200px;
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _vm._m(0);
                },
                staticRenderFns: [function () {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "box"
                    }, [_vm._v("200x200")])]);
                }]
            };return options;
        }();
        var Component = function () {
            return {};
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="css">避免CSS类选择器冲突</h3>
<div class="rule rule-4">
                        <div class="rule-right">
                        <div class="rule-txt"><p>为了避免组件之间或组件与使用页面之间的CLASS类冲突，导致CSS样式的冲突。推荐使用<a href="http://getbem.com/naming/">BEM</a>、<a href="https://suitcss.github.io/">SUIT</a>、<a href="https://smacss.com/">SMACSS</a>之类的CLASS命名规范。当然也可以自己规范一套命名规范。</p>
<p>使用BEM或SUIT规范时，推荐使用<a href="https://github.com/kezzbracey/postcss-bem">postcss-bem</a>插件。它提供了@规则，可以简化CSS代码书写。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">// BEM规范</span>
<span class="hljs-variable">@component-namespace</span> v {
    <span class="hljs-variable">@b</span> input {
        <span class="hljs-comment">// TODO</span>
        <span class="hljs-variable">@m</span> search {
            <span class="hljs-comment">// TODO</span>
        }
        <span class="hljs-variable">@e</span> placeholder {
            <span class="hljs-comment">// TODO</span>
        }
    }
}

<span class="hljs-comment">// 自定义规范</span>
.input {
    <span class="hljs-comment">// TODO</span>
}
.input-search {
    <span class="hljs-comment">// TODO</span>
}
.input-placeholder {
    <span class="hljs-comment">// TODO</span>
}

</code></pre>
                        
                
</div></div></div>
<h3 id="currentcolorcolorinherit">使用<code>currentColor</code>和<code>color:inherit</code></h3>
<div class="rule rule-5">
                        <div class="rule-right">
                        <div class="rule-txt"><p>如果组件颜色较为单一，可以使用<code>currentColor</code>来设置颜色。这样在组件外部就可以通过设置根节点的<code>color</code>属性来轻松控制组件的颜色。</p>
<p>如果需要设置颜色的节点不是根节点，还可以和<code>color:inherit</code>配合使用，继承根节点的<code>color</code>值。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-button"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Layer_1"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span> <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">"http://www.w3.org/1999/xlink"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"0px"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0px"</span>
        <span class="hljs-attr">width</span>=<span class="hljs-string">"24px"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"24px"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 24 24"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"enable-background:new 0 0 24 24;"</span> <span class="hljs-attr">xml:space</span>=<span class="hljs-string">"preserve"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">g</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M12,0C5.373,0,0,5.373,0,12s5.373,12,12,12s12-5.373,12-12S18.627,0,12,0z M12,22
                C6.477,22,2,17.521,2,12C2,6.477,6.477,2,12,2c5.523,0,10,4.478,10,10C22,17.521,17.523,22,12,22z"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M12.5,6h-1C11.224,6,11,6.224,11,6.5v7c0,0.275,0.224,0.5,0.5,0.5h1c0.275,0,0.5-0.225,0.5-0.5v-7
                C13,6.224,12.775,6,12.5,6z"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M12.5,16h-1c-0.276,0-0.5,0.225-0.5,0.5v1c0,0.275,0.224,0.5,0.5,0.5h1c0.275,0,0.5-0.225,0.5-0.5
                v-1C13,16.225,12.775,16,12.5,16z"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
        按钮
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="undefined">
// 组件样式
@component-namespace x {
    @b button {
        display: inline-block;
        margin: 0;
        padding: 9px 0;
        width: 80px;
        height: 40px;
        line-height: 20px;
        font-size: 14px;
        vertical-align: middle;
        text-align: center;
        color: #c92a2a;
        cursor: pointer;
        border: 1px solid currentColor;
        background: transparent;
        box-sizing: border-box;

        svg {
            color: inherit;
            fill: currentColor;
            width: 16px;
            height: 16px;
            display: inline-block;
            vertical-align: -3px;
        }
    }
}

.module-css .rule-5 {
    // 使用组件时候的样式
    .x-button {
        color: #4dadf7;

        &amp;:hover {
            color: #228ae6;
        }
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "x-button"
                    }, [_c('svg', {
                        staticStyle: {
                            "enable-background": "new 0 0 24 24"
                        },
                        attrs: {
                            "version": "1.1",
                            "id": "Layer_1",
                            "xmlns": "http://www.w3.org/2000/svg",
                            "xmlns:xlink": "http://www.w3.org/1999/xlink",
                            "x": "0px",
                            "y": "0px",
                            "width": "24px",
                            "height": "24px",
                            "viewBox": "0 0 24 24",
                            "xml:space": "preserve"
                        }
                    }, [_c('g', [_c('path', {
                        attrs: {
                            "d": "M12,0C5.373,0,0,5.373,0,12s5.373,12,12,12s12-5.373,12-12S18.627,0,12,0z M12,22\n                C6.477,22,2,17.521,2,12C2,6.477,6.477,2,12,2c5.523,0,10,4.478,10,10C22,17.521,17.523,22,12,22z"
                        }
                    }), _vm._v(" "), _c('path', {
                        attrs: {
                            "d": "M12.5,6h-1C11.224,6,11,6.224,11,6.5v7c0,0.275,0.224,0.5,0.5,0.5h1c0.275,0,0.5-0.225,0.5-0.5v-7\n                C13,6.224,12.775,6,12.5,6z"
                        }
                    }), _vm._v(" "), _c('path', {
                        attrs: {
                            "d": "M12.5,16h-1c-0.276,0-0.5,0.225-0.5,0.5v1c0,0.275,0.224,0.5,0.5,0.5h1c0.275,0,0.5-0.225,0.5-0.5\n                v-1C13,16.225,12.775,16,12.5,16z"
                        }
                    })])]), _vm._v("\n        按钮\n    ")])]);
                },
                staticRenderFns: []
            };return options;
        }();
        var Component = function () {
            return {};
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="-3">组件尽量自适应高宽</h3>
<div class="rule rule-6">
                        <div class="rule-right">
                        <div class="rule-txt"><p>组件的高宽很可能会被修改，此时如果组件内部是自适应变化的，那么就可以大大提高组件的易用性。组件的使用者在外部只需要通过CSS的<code>width</code>和<code>height</code>就可以方便的修改组件的高宽，通常会配合<code>box-sizing:border-box</code>一起使用。</p>
<p>在开发组件时一定要把高宽变化的情况考虑在内，尽量做到组件内部自适应高宽。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-input x-input--search"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"0px"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0px"</span>
        <span class="hljs-attr">width</span>=<span class="hljs-string">"20px"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"20px"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 20 20"</span> <span class="hljs-attr">xml:space</span>=<span class="hljs-string">"preserve"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"fill-rule:evenodd;clip-rule:evenodd;"</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M17.696,16.227l-2.531-2.532c2.5-2.748,2.431-6.999-0.223-9.653
        c-2.734-2.733-7.166-2.733-9.899,0c-2.734,2.734-2.734,7.166,0,9.9c2.306,2.306,5.819,2.659,8.503,1.073l2.681,2.682
        c0.406,0.406,1.063,0.406,1.469,0S18.102,16.633,17.696,16.227z M6.457,12.527c-1.953-1.952-1.953-5.118,0-7.071
        s5.118-1.953,7.071,0c1.952,1.953,1.952,5.119,0,7.071C11.575,14.48,8.409,14.48,6.457,12.527z"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-input__txt"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="undefined">
// 组件样式
@component-namespace x {
    @b input {
        display: inline-block;
        margin: 0;
        padding: 0 10px;
        width: 400px;
        height: 40px;
        line-height: 40px;
        vertical-align: middle;
        text-align: center;
        color: #495057;
        border: 2px solid currentColor;
        background: #FFF;
        box-sizing: border-box;

        @m search {
            padding-left: 40px;
        }

        svg {
            margin: 8px 0 0 -30px;
            float: left;
            width: 20px;
            height: 20px;
            fill: currentColor;
            color: inherit;
        }

        @e txt {
            display: block;
            width: 100%;
            height: 100%;
            padding: 0;
            border: 0;
            font-size: 20px;
            color: inherit;
            outline: none;
        }
    }
}

.module-css .rule-6 {
    // 使用组件时候的样式
    .x-input {
        width: 300px;
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "x-input x-input--search"
                    }, [_c('svg', {
                        attrs: {
                            "version": "1.1",
                            "x": "0px",
                            "y": "0px",
                            "width": "20px",
                            "height": "20px",
                            "viewBox": "0 0 20 20",
                            "xml:space": "preserve"
                        }
                    }, [_c('path', {
                        staticStyle: {
                            "fill-rule": "evenodd",
                            "clip-rule": "evenodd"
                        },
                        attrs: {
                            "d": "M17.696,16.227l-2.531-2.532c2.5-2.748,2.431-6.999-0.223-9.653\n        c-2.734-2.733-7.166-2.733-9.899,0c-2.734,2.734-2.734,7.166,0,9.9c2.306,2.306,5.819,2.659,8.503,1.073l2.681,2.682\n        c0.406,0.406,1.063,0.406,1.469,0S18.102,16.633,17.696,16.227z M6.457,12.527c-1.953-1.952-1.953-5.118,0-7.071\n        s5.118-1.953,7.071,0c1.952,1.953,1.952,5.119,0,7.071C11.575,14.48,8.409,14.48,6.457,12.527z"
                        }
                    })]), _vm._v(" "), _c('input', {
                        staticClass: "x-input__txt"
                    })])]);
                },
                staticRenderFns: []
            };return options;
        }();
        var Component = function () {
            return {};
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="css-rest">单个组件内CSS REST</h3>
<div class="rule rule-7">
                        <div class="rule-right">
                        <div class="rule-txt"><p>为了确保<strong>组件在各个页面下最终呈现的样子是一致的</strong>，需要对组件内CSS进行一定程度上的样式重置。</p>
<p>我们推荐的为根节点添加<code>display</code>样式，以确保其样式的稳定性。对于块级组件<code>display</code>值是<code>block</code>；对于行内组件值是<code>inline-block</code>；对于占位类型的组件值是<code>inline</code>；所谓的占位类型，就是其本身不提供任何样式，只是留一个标签在那里做占位。</p>
<p>CSS RESET可以参考右边例子。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-selector-class">.reset</span> {
    <span class="hljs-attribute">display</span>: inline-block;      <span class="hljs-comment">// 或者 block，特殊情况下用inline</span>
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;     <span class="hljs-comment">// IE8+以后支持，在有`border`的时候外部可以更轻松的控制组件宽高</span>
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;            <span class="hljs-comment">//</span>
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;          <span class="hljs-comment">//</span>
    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 不适用浏览器默认focus状态，可以自定义</span>

    <span class="hljs-comment">// 重置组件内部的常用标签</span>
    <span class="hljs-selector-tag">div</span>, <span class="hljs-selector-tag">span</span>, <span class="hljs-selector-tag">object</span>, <span class="hljs-selector-tag">iframe</span>, <span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">h4</span>, <span class="hljs-selector-tag">h5</span>, <span class="hljs-selector-tag">h6</span>, <span class="hljs-selector-tag">p</span>,
    <span class="hljs-selector-tag">pre</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">abbr</span>, <span class="hljs-selector-tag">address</span>, <span class="hljs-selector-tag">code</span>, <span class="hljs-selector-tag">del</span>, <span class="hljs-selector-tag">dfn</span>, <span class="hljs-selector-tag">em</span>, <span class="hljs-selector-tag">img</span>,
    <span class="hljs-selector-tag">dl</span>, <span class="hljs-selector-tag">dt</span>, <span class="hljs-selector-tag">dd</span>, <span class="hljs-selector-tag">ol</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">li</span>, <span class="hljs-selector-tag">fieldset</span>, <span class="hljs-selector-tag">form</span>, <span class="hljs-selector-tag">label</span>,
    <span class="hljs-selector-tag">legend</span>, <span class="hljs-selector-tag">caption</span>, <span class="hljs-selector-tag">tbody</span>, <span class="hljs-selector-tag">tfoot</span>, <span class="hljs-selector-tag">thead</span>, <span class="hljs-selector-tag">tr</span>,
    <span class="hljs-comment">// html5 标签</span>
    <span class="hljs-selector-tag">article</span>, <span class="hljs-selector-tag">aside</span>, <span class="hljs-selector-tag">details</span>, <span class="hljs-selector-tag">figcaption</span>,
    <span class="hljs-selector-tag">figure</span>, <span class="hljs-selector-tag">footer</span>, <span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">hgroup</span>, <span class="hljs-selector-tag">menu</span>, <span class="hljs-selector-tag">nav</span>,
    <span class="hljs-selector-tag">section</span>, <span class="hljs-selector-tag">summary</span>, <span class="hljs-selector-tag">main</span> {
        <span class="hljs-comment">// 盒模型重置</span>
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">box-sizing</span>: content-box;
        <span class="hljs-comment">// focus状态</span>
        <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 文本</span>
        <span class="hljs-attribute">font-weight</span>: inherit;
        <span class="hljs-attribute">font-style</span>: inherit;
        <span class="hljs-attribute">font-family</span>: inherit;
        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100%</span>;
        <span class="hljs-attribute">color</span>: inherit;
        <span class="hljs-attribute">vertical-align</span>: baseline;
    }

    <span class="hljs-comment">// 设置成块级标签</span>
    <span class="hljs-selector-tag">div</span>, <span class="hljs-selector-tag">p</span>, <span class="hljs-selector-tag">pre</span>,
    <span class="hljs-selector-tag">iframe</span>, <span class="hljs-selector-tag">audio</span>, <span class="hljs-selector-tag">canvas</span>, <span class="hljs-selector-tag">video</span>,   <span class="hljs-comment">// 本来不是块级元素，但大都作为块级元素使用</span>
    <span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span>, <span class="hljs-selector-tag">h3</span>, <span class="hljs-selector-tag">h4</span>, <span class="hljs-selector-tag">h5</span>, <span class="hljs-selector-tag">h6</span>,
    <span class="hljs-selector-tag">dl</span>, <span class="hljs-selector-tag">dt</span>, <span class="hljs-selector-tag">dd</span>, <span class="hljs-selector-tag">ol</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">li</span>,
    <span class="hljs-selector-tag">fieldset</span>, <span class="hljs-selector-tag">form</span>, <span class="hljs-selector-tag">legend</span>,
    <span class="hljs-comment">// html5 标签</span>
    <span class="hljs-selector-tag">article</span>, <span class="hljs-selector-tag">aside</span>, <span class="hljs-selector-tag">details</span>, <span class="hljs-selector-tag">figcaption</span>,
    <span class="hljs-selector-tag">figure</span>, <span class="hljs-selector-tag">footer</span>, <span class="hljs-selector-tag">header</span>, <span class="hljs-selector-tag">hgroup</span>, <span class="hljs-selector-tag">menu</span>, <span class="hljs-selector-tag">nav</span>,
    <span class="hljs-selector-tag">section</span>, <span class="hljs-selector-tag">summary</span>, <span class="hljs-selector-tag">main</span> {
        <span class="hljs-attribute">display</span>: block;
        <span class="hljs-attribute">line-height</span>: inherit;
    }
    <span class="hljs-selector-tag">ol</span>, <span class="hljs-selector-tag">ul</span> {
        <span class="hljs-attribute">list-style</span>: none;
    }
    <span class="hljs-selector-tag">table</span> {
        <span class="hljs-attribute">border-collapse</span>: separate;
        <span class="hljs-attribute">border-spacing</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attribute">vertical-align</span>: middle;
    }
    <span class="hljs-selector-tag">caption</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
        <span class="hljs-attribute">text-align</span>: inherit;
        <span class="hljs-attribute">font-weight</span>: inherit;
        <span class="hljs-attribute">vertical-align</span>: middle;
    }

    <span class="hljs-comment">// 行内元素</span>
    <span class="hljs-selector-tag">span</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">label</span>,
    <span class="hljs-selector-tag">abbr</span>, <span class="hljs-selector-tag">address</span>, <span class="hljs-selector-tag">code</span>, <span class="hljs-selector-tag">del</span>, <span class="hljs-selector-tag">dfn</span>, <span class="hljs-selector-tag">em</span> {
        <span class="hljs-attribute">display</span>: inline;
    }
    <span class="hljs-selector-tag">img</span>, <span class="hljs-selector-tag">object</span>, <span class="hljs-selector-tag">audio</span>, <span class="hljs-selector-tag">canvas</span>, <span class="hljs-selector-tag">video</span> {
        <span class="hljs-attribute">display</span>: inline-block;
    }
}
</code></pre>
                        
                
</div></div></div>
</div><div class="module module-javascript"><h2 id="javascript">Javascript篇</h2>
<h3 id="constlet">使用<code>const</code>和<code>let</code></h3>
<div class="rule rule-8">
                        <div class="rule-right">
                        <div class="rule-txt"><p>ES6 现在支持了<code>const</code>和<code>let</code>关键字，相比<code>var</code>它们支持了块级作用域。并且<code>const</code>用于常量的声明，<code>let</code>用于变量的声明。它们本身有更加明确的用途，对代码的可读性也有一定的提高。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">// 错误例子1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueByCode</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">var</span> VALUE_MAP = {
        <span class="hljs-number">200</span>: <span class="hljs-string">'success'</span>,
        <span class="hljs-number">300</span>: <span class="hljs-string">'REDIRECT'</span>,
        <span class="hljs-number">400</span>: <span class="hljs-string">'CLIENT ERROR'</span>,
        <span class="hljs-number">500</span>: <span class="hljs-string">'SERVER ERROR'</span>
    };
    <span class="hljs-keyword">return</span> VALUE_MAP[code];
}
<span class="hljs-comment">// 正确例子1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValueByCode</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">const</span> VALUE_MAP = {
        <span class="hljs-number">200</span>: <span class="hljs-string">'success'</span>,
        <span class="hljs-number">300</span>: <span class="hljs-string">'REDIRECT'</span>,
        <span class="hljs-number">400</span>: <span class="hljs-string">'CLIENT ERROR'</span>,
        <span class="hljs-number">500</span>: <span class="hljs-string">'SERVER ERROR'</span>
    };
    <span class="hljs-keyword">return</span> VALUE_MAP[code];
}


<span class="hljs-comment">// 错误例子2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAncestor</span>(<span class="hljs-params">component, ancestorName</span>) </span>{
    <span class="hljs-keyword">var</span> parent = component.$parent;
    <span class="hljs-keyword">while</span> (parent.$options.name !== ancestorName) {
        parent = parent.$parent;
    }
    <span class="hljs-keyword">return</span> parent;
}
<span class="hljs-comment">// 正确例子2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAncestor</span>(<span class="hljs-params">component, ancestorName</span>) </span>{
    <span class="hljs-keyword">let</span> parent = component.$parent;
    <span class="hljs-keyword">while</span> (parent.$options.name !== ancestorName) {
        parent = parent.$parent;
    }
    <span class="hljs-keyword">return</span> parent;
}
</code></pre>
                        
                
</div></div></div>
<h3 id="else">减少使用<code>else</code>关键字</h3>
<div class="rule rule-9">
                        <div class="rule-right">
                        <div class="rule-txt"><p>我们在编写javascript代码时，会经常用到<code>if else</code>来处理分支逻辑。当分支逻辑只有两层时，这不是什么问题。但当分支逻辑越来越多时，就会出现很多层的<code>if else</code>嵌套。这会大大降低代码的可读性。</p>
<p>推荐按照如下规则来尽量减少<code>else</code>关键字的使用：</p>
<ul>
<li>如果代码逻辑有两个以上的分支
<ul>
<li>如果代码逻辑简单只是返回对应值的匹配值，则推荐使用字典对象；</li>
<li>如果只有一条分支逻辑负责其余都很简单，则推荐使用<code>if return</code>；</li>
<li>如果有两条以上分支逻辑复杂，推荐使用<code>switch</code>关键字（如果分支逻辑非常复杂推荐）；</li>
</ul>
</li>
<li>如果代码逻辑只有两个分支
<ul>
<li>如果分支逻辑简单，则优先尝试使用条件运算符；</li>
<li>如果分支逻辑复杂，则推荐使用<code>if return</code>；</li>
</ul>
</li>
</ul>
<p>PS：在代码逻辑只有两个分支并且使用<code>if return</code>时，推荐把简单的分支逻辑立即先<code>return</code>掉。把复杂的逻辑放在后面，这样复杂逻辑的缩进会少。代码的可读性会进一步提高。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">// 错误样例1：两个分支，且逻辑简单</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValue</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (value &amp;&amp; (value.length != <span class="hljs-literal">null</span>)) {
        <span class="hljs-keyword">return</span> !!value.length;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> !!value;
    }
}
<span class="hljs-comment">// 正确样例1：使用条件运算符</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasValue</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// 增加一个有意义的变量名，提高代码可读性</span>
    <span class="hljs-keyword">const</span> isStringOrArray = value &amp;&amp; (value.length != <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">return</span> !!(isStringOrArray ? value.length : value);
}


<span class="hljs-comment">// 错误样例2：两个以上分支，且逻辑简单</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-keyword">if</span> (code === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'success'</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code === <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'client error'</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (code === <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'server error'</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'unknown error'</span>;
    }
}
<span class="hljs-comment">// 正确样例2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">code</span>) </span>{
    <span class="hljs-comment">// 此样例中也可以使用数组来做map，不过对象支持更普遍一些</span>
    <span class="hljs-keyword">const</span> CODE_MAP = {
        <span class="hljs-number">1</span>: <span class="hljs-string">'success'</span>,
        <span class="hljs-number">2</span>: <span class="hljs-string">'client error'</span>,
        <span class="hljs-number">3</span>: <span class="hljs-string">'server error'</span>
    };
    <span class="hljs-keyword">return</span> CODE_MAP[code] || <span class="hljs-string">'unknown error'</span>;
}


<span class="hljs-comment">// 错误样例3：两个分支，且只有一个分支逻辑复杂</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getConfig</span>(<span class="hljs-params">id, callback</span>) </span>{
    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">const</span> params = {
            <span class="hljs-comment">// TODO calculate params</span>
        };
        $.post(<span class="hljs-string">'/config'</span>, params, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">if</span> (data.success) {
                callback(data.data);
            }
            <span class="hljs-keyword">else</span> {
                callback(<span class="hljs-literal">null</span>);
            }
        });
    }
    <span class="hljs-keyword">else</span> {
        callback(<span class="hljs-literal">null</span>);
    }
}
<span class="hljs-comment">// 正确样例3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getConfig</span>(<span class="hljs-params">id, callback</span>) </span>{
    <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) {
        callback(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> params = {
        <span class="hljs-comment">// TODO calculate params</span>
    };
    $.post(<span class="hljs-string">'/config'</span>, params, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
        callback(data.success ? data.data : <span class="hljs-literal">null</span>);
    });
}


<span class="hljs-comment">// 错误样例4：两个以上分支，且有多个分支逻辑复杂</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calc</span>(<span class="hljs-params">position, relative</span>) </span>{
    <span class="hljs-keyword">if</span> (position === <span class="hljs-string">'top'</span> || position === <span class="hljs-string">'bottom'</span>) {
        calcVertical(relative);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === <span class="hljs-string">'left'</span> || position === <span class="hljs-string">'right'</span>) {
        calcHorizontal(relative);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// TODO</span>
    }
}
<span class="hljs-comment">// 正确样例4</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calc</span>(<span class="hljs-params">position, relative</span>) </span>{
    <span class="hljs-keyword">switch</span> (position) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'top'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom'</span>:
            calcVertical(relative);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'left'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'right'</span>:
            calcHorizontal(relative);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-comment">// TODO</span>
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
                        
                
</div></div></div>
<h3 id="mapfilterreducefor">使用<code>map/filter/reduce</code>替代<code>for</code>循环</h3>
<div class="rule rule-10">
                        <div class="rule-right">
                        <div class="rule-txt"><p>在ES5之前，我们操作Javascript数组的常用方式是使用<code>for</code>循环。这是一种传统且非常高效的做法。在ES5之后，Javascript的数组引入了很多的原生方法，例如<code>Array.prototype.forEach</code>方法。这些特性的支持程度可以看<a href="http://kangax.github.io/compat-table/es5/">这个表</a>。</p>
<p>于是大家开始争论使用<code>for</code>循环还是<code>forEach</code>方法，甚至有人做了<a href="https://jsperf.com/for-vs-foreach/75">性能对比</a>。<code>for</code>循环的优势在于：性能好，并且能够通过<code>break</code>关键字快速退出。 <code>forEach</code>方法的优势在于：可读性高，易于使用（天然带有闭包）。</p>
<p>这里要说的不是<code>for</code>循环 VS <code>forEach</code>方法，而是<code>for</code>循环 VS <code>map/filter/reduce</code>方法。通过下面这张图你可以清楚地知道它们的作用。</p>
<p><a href="https://twitter.com/apasella/status/741168882958880768"><img src="./static/map_filter_reduce.png" alt="" width="300"></a></p>
<p>虽然<code>for</code>循环有着更好的性能，但是只要不是超大型数组，性能优势并不明显。相反<code>map/filter/reduce</code>方法却可以大大提高代码的可读性，所以更推荐使用他们。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">// 错误例子1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValues</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">const</span> values = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; opts.length; i++) {
        values.push(opts[i].value);
    }
    <span class="hljs-keyword">return</span> values;
}
<span class="hljs-comment">// 正确例子1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValues</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">return</span> opts.map(<span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> opt.value);
}


<span class="hljs-comment">// 错误例子2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelectedOptions</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">const</span> selectedOpts = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; opts.length; i++) {
        <span class="hljs-keyword">if</span> (opts[i].selected) {
            selectedOpts.push(opts[i]);
        }
    }
    <span class="hljs-keyword">return</span> selectedOpts;
}
<span class="hljs-comment">// 正确例子2</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelectedOptions</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">return</span> opts.filter(<span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> opt.selected);
}


<span class="hljs-comment">// 错误例子3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumSelectedValue</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; opts.length; i++) {
        <span class="hljs-keyword">if</span> (opts[i].selected) {
            sum += opts[i].value;
        }
    }
    <span class="hljs-keyword">return</span> sum;
}
<span class="hljs-comment">// 正确例子3</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumSelectedValue</span>(<span class="hljs-params">opts</span>) </span>{
    <span class="hljs-keyword">return</span> opts
        .filter(<span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span> opt.selected)
        .reduce(<span class="hljs-function">(<span class="hljs-params">result, opt</span>) =&gt;</span> result + opt.value, <span class="hljs-number">0</span>);
}
</code></pre>
                        
                
</div></div></div>
</div><div class="module module-vue"><h2 id="vue">Vue篇</h2>
<h3 id="v-bindv-on">使用<code>v-bind</code>和<code>v-on</code>的快捷方法</h3>
<div class="rule rule-11">
                        <div class="rule-right">
                        <div class="rule-txt"><p>Vue 为<code>v-bind</code>和<code>v-on</code>指令提供了两个快捷方法，虽然这看起来和普通的HTML风格不一样，但是<code>:</code>和<code>@</code>字符也是可以作为HTML属性名的。</p>
<p>推荐优先使用它们，这可以大大提高写代码的速度以及代码的可读性。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 错误例子1 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 正确例子1 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 错误例子2 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 正确例子2 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"url"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
                        
                
</div></div></div>
<h3 id="props">简化<code>props</code>的类型</h3>
<div class="rule rule-12">
                        <div class="rule-right">
                        <div class="rule-txt"><p>Vue组件的<code>props</code>是其最重要的对外API，推荐在设计这些<code>props</code>时尽量确保它们的类型简化，不要使用一个非常复杂的对象或者数组。尽量确保其<code>props</code>类型是字符串、数字、布尔值之类的基本类型，即使真的需要用到对象和数组，也可以尽量简化其内部项的类型。</p>
<p>这么设计有几个好处：</p>
<ol>
<li>属性分离，可以使得<code>props</code>有更好的语义化、功能更加清晰、易于理解</li>
<li>基本类型的<code>props</code>可以直接在模板中作为字面量使用。但如果是对象和函数类型的字面量，那么因为模板每次都会重新生成<code>props</code>值，相当于每次渲染时得到的<code>props</code>是不同的，会导致<code>watch</code>回调函数的不必要触发</li>
</ol>
<p>但是也并不是所有的组件都一定要使用基本类型的<code>props</code>，如果基本类型并不能满足需求或者并不是特别好用，那么还是推荐使用对象或数组类型。</p>
<p>举个例子，<code>tab</code>组件的可选tab数据更多是当前页面固定不变的，而<code>tree</code>的可选值数据更多的是动态输出（存储在后端）的。所以推荐<code>tab</code>组件的可选tab数据使用简单类型，而<code>tree</code>使用数组类型。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 正确例子 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">x-tabs</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-tab</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">x-tab</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-tab</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>&gt;</span>动画<span class="hljs-tag">&lt;/<span class="hljs-name">x-tab</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-tab</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>&gt;</span>电影<span class="hljs-tag">&lt;/<span class="hljs-name">x-tab</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-tab</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"4"</span>&gt;</span>电视剧<span class="hljs-tag">&lt;/<span class="hljs-name">x-tab</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-tab</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span>&gt;</span>其他<span class="hljs-tag">&lt;/<span class="hljs-name">x-tab</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">x-tabs</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">x-tree</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"selectedProductionId"</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">"productionTree"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-tree</span>&gt;</span>
</code></pre>
                        
                
</div></div></div>
<h3 id="propsdata"><code>props</code>和<code>data</code></h3>
<div class="rule rule-13">
                        <div class="rule-right">
                        <div class="rule-txt"><p>Vue 的<code>props</code>和<code>data</code>配置有点相似，但又完全不一样。<strong><code>props</code>其实是组件对外部的属性接口，而<code>data</code>是组件内部的可变状态。</strong></p>
<p>从Vue 2.0开始，<code>props</code>便不能通过<code>this.prop = newValue;</code>的赋值方式来修改（在debug模式下会报错），必须在组件外部通过属<code>v-bind/v-model</code>指令的方式由父组件传输过来新的值。而<code>data</code>则是可以在组件内外部来直接用Javascript赋值来修改的，不过很少会在组件外直接修改组件的<code>data</code>值。</p>
<p>所以我们已经可以得到如下几个结论：</p>
<ol>
<li>如果这个状态不应该被组件外部修改，则只使用<code>data</code></li>
<li>如果这个状态应该被组件外部修改
<ol>
<li>如果这个状态不会被内部修改（用户交互或其他原因导致），则只使用<code>props</code></li>
<li>如果这个状态会被内部修改，则需要同时使用<code>data</code>和<code>props</code></li>
</ol>
</li>
</ol>
<p>因为<code>props</code>和<code>data</code>不能同名，所以必须要区分一下。我们来看一个简单的输入框组件<code>x-input</code>的案例。</p>
<p>输入框的值即需要被外部组件控制修改，也同时需要能够让用户键盘输入来修改。所以定义了一个<code>props</code>名为<code>value</code>被外部使用，再定义一个<code>currentValue</code>作为<code>data</code>被内部修改。具体结构看下图：</p>
<p><img src="./static/vue_props_data.png" alt="" width="400"></p>
<p>绿色为组件实例，蓝色为<code>props</code>，黄色为<code>data</code>。初始化时<code>currentValue</code>的值会被赋值为<code>value</code>的值，并watch <code>value</code>值变化，如果外部修改<code>inputValue</code>则会立即更新<code>currentValue</code>。如果用户输入，则会更新<code>currentValue</code>并触发<code>input</code>事件然后通知<code>inputValue</code>新的值。</p>
<p>这里会有一个死循环在内部，但是由于Vue的watch机制是在值发生变化（===）时才触发回调，所以不存在问题。所以你需要确保一个状态不应该有多个不同的引用值。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">&lt;!-- x-container --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"inputValue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-input</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{inputValue}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'XContainer'</span>,
        data() {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">inputValue</span>: <span class="hljs-string">'输入框文字'</span>
            };
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- x-input --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-input"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-input__txt"</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"currentValue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'XInput'</span>,
        <span class="hljs-attr">props</span>: {
            <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>,
            <span class="hljs-attr">value</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>]
        },
        data() {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">currentValue</span>: <span class="hljs-keyword">this</span>.value
            };
        },
        <span class="hljs-attr">watch</span>: {
            value(nextValue) {
                <span class="hljs-keyword">this</span>.currentValue = nextValue;
            },
            currentValue(nextValue) {
                <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'input'</span>, nextValue);
            }
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    tmp = function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('span', {
                        staticClass: "x-input"
                    }, [_c('input', {
                        directives: [{
                            name: "model",
                            rawName: "v-model",
                            value: _vm.currentValue,
                            expression: "currentValue"
                        }],
                        staticClass: "x-input__txt",
                        attrs: {
                            "name": _vm.name
                        },
                        domProps: {
                            "value": _vm.currentValue
                        },
                        on: {
                            "input": function input($event) {
                                if ($event.target.composing) {
                                    return;
                                }
                                _vm.currentValue = $event.target.value;
                            }
                        }
                    })])]);
                },
                staticRenderFns: []
            };return options;
        }();
        var Component = function () {

            return {
                name: 'XInput',
                props: {
                    name: String,
                    value: [String, Number]
                },
                data: function data() {
                    return {
                        currentValue: this.value
                    };
                },

                watch: {
                    value: function value(nextValue) {
                        this.currentValue = nextValue;
                    },
                    currentValue: function currentValue(nextValue) {
                        this.$emit('input', nextValue);
                    }
                }
            };
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }();
    Vue.component(tmp.name, tmp);

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('x-input', {
                        attrs: {
                            "name": "username"
                        },
                        model: {
                            value: _vm.inputValue,
                            callback: function callback($$v) {
                                _vm.inputValue = $$v;
                            },
                            expression: "inputValue"
                        }
                    }), _vm._v(" "), _c('div', [_vm._v(_vm._s(_vm.inputValue))])], 1);
                },
                staticRenderFns: []
            };return options;
        }();
        var Component = function () {

            return {
                name: 'XContainer',
                data: function data() {
                    return {
                        inputValue: '输入框文字'
                    };
                }
            };
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="">适度且灵活地使用模板的行内表达式</h3>
<div class="rule rule-14">
                        <div class="rule-right">
                        <div class="rule-txt"><p>Vue 内置的模板很强大，设置提供了行内表达式功能。这让过去很麻烦难以处理的情况变得很简单，比如获取列表内点击行的数据。</p>
<p>过去我们需要在渲染列表每一行的时候，把对应数据项的ID或者索引值作为<code>li</code>元素的<code>data-id</code>属性的值；然后在<code>ul</code>元素上绑定点击事件，通过事件代理拿到当前点击的<code>li</code>元素；然后获取<code>li</code>元素的<code>data-id</code>值，然后得到对应的数据项。</p>
<p>而使用Vue之后，只需要通过行内表达式就可以轻易地做到，见右边。</p>
<blockquote>
<p>虽然行内表达很强大，但是并不推荐在表达式内写太复杂的逻辑。因为它可读性差，且难以复用。</p>
<p>如果只是用来作为显示，则更推荐使用<code>computed</code>；如果是用来做复杂的执行，则推荐把值传给<code>methods</code>的方式；</p>
</blockquote>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"clickedItem = item"</span>&gt;</span>
            {{item.name}}
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Clicked item name: {{clickedItem.name || ''}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
        data() {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">list</span>: [
                    {<span class="hljs-attr">name</span>: <span class="hljs-string">'Vue'</span>},
                    {<span class="hljs-attr">name</span>: <span class="hljs-string">'Angular'</span>},
                    {<span class="hljs-attr">name</span>: <span class="hljs-string">'React'</span>},
                    {<span class="hljs-attr">name</span>: <span class="hljs-string">'jQuery'</span>}
                ],
                <span class="hljs-attr">clickedItem</span>: {}
            };
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
                        
            <script>'use strict';

(function () {
    var tmp = void 0;

    var DemoComponent = Vue.extend(function () {
        var Template = function () {
            var options = {
                render: function render() {
                    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;
                    return _c('div', {
                        staticClass: "component"
                    }, [_c('ul', _vm._l(_vm.list, function (item) {
                        return _c('li', {
                            on: {
                                "click": function click($event) {
                                    _vm.clickedItem = item;
                                }
                            }
                        }, [_vm._v("\n            " + _vm._s(item.name) + "\n        ")]);
                    })), _vm._v(" "), _c('div', [_vm._v("Clicked item name: " + _vm._s(_vm.clickedItem.name || ''))])]);
                },
                staticRenderFns: []
            };return options;
        }();
        var Component = function () {

            return {
                data: function data() {
                    return {
                        list: [{ name: 'Vue' }, { name: 'Angular' }, { name: 'React' }, { name: 'jQuery' }],
                        clickedItem: {}
                    };
                }
            };
        }();
        Component.render = Template.render;
        Component.staticRenderFns = Template.staticRenderFns;
        return Component;
    }());
    var scripts = document.getElementsByTagName('script');
    var script = scripts[scripts.length - 1];
    var ruleDemo = document.createElement('div');
    ruleDemo.className = 'rule-demo';
    var div = document.createElement('div');
    ruleDemo.appendChild(div);
    var textDiv = script.parentNode.previousElementSibling;
    textDiv.insertBefore(ruleDemo, textDiv.firstChild);
    new DemoComponent().$mount(div);
})();</script>
        
                
</div></div></div>
<h3 id="parent">尽量少使用<code>$parent</code></h3>
<div class="rule rule-15">
                        <div class="rule-right">
                        <div class="rule-txt"><p>在 Vue 中，父子组件的数据传输主要依靠属性的由上向下传输，也就是所谓的单向数据流。当子组件想要向父组件传输数据时，一般使用事件。</p>
<p>你可能会想到<code>v-model</code>或者<code>v-bind.sync</code>（2.0开时移除但2.3.0+重新增加）的双向绑定，其实它的内部实现机制也是依赖了单向数据流和事件，只是提供了一个简单的快捷方式而已。</p>
<p>当然还有另一个自下向上传输数据的方式，就是<code>$parent</code>。但是应该尽量减少它的使用，如果使用了<code>$parent</code>则要考虑到不包含指定<code>$parent</code>的情况。</p>
<blockquote>
<p>主要原因是：一个组件应该能独立运行，不应该过度依赖其父组件。这会导致其不能在其他更为复杂的上下文中不能使用。例如父子组件之间插入了另一个其他组件，见右边代码。</p>
</blockquote>
<p>不过这个情况也并不绝对，比如右边的<code>x-form</code>与<code>x-form-item</code>。这两个组件是互相配合使用的，<code>x-form-item</code>不需要支持独立使用。但是我们也并不一定要使用<code>$parent</code>，更推荐使用<code>provide &amp;&amp; inject</code>机制。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-comment">&lt;!-- 正常例子 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">x-form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">x-input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0067ED"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">x-input</span> <span class="hljs-attr">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">x-form</span>&gt;</span>


<span class="hljs-comment">&lt;!-- 异常例子 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">x-form</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 加入了水平布局的组件，导致了父子级关系改变 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-layout</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">x-input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0067ED"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-input</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-layout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-layout</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">x-input</span> <span class="hljs-attr">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x-input</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-layout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">x-layout</span> <span class="hljs-attr">align</span>=<span class="hljs-string">"horizontal"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">x-form-item</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">x-form-item</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">x-layout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">x-form</span>&gt;</span>
</code></pre>
                        
                
</div></div></div>
<h3 id="provide-inject"><code>provide</code> 与 <code>inject</code> 实现上下数据传输</h3>
<div class="rule rule-16">
                        <div class="rule-right">
                        <div class="rule-txt"><p>在Vue中，直接的父子组件可以通过属性和事件机制轻松地实现数据传输。但是属性和事件机制并不能覆盖到所有的情况：</p>
<ul>
<li>祖孙关系的组件</li>
<li>父组件传输数据给<code>slot</code>中的子组件</li>
</ul>
<p>为了解决这些场景的数据传输问题。Vue自2.2.0开始，新增了<code>provide</code>与<code>inject</code>配置。通过它们可以轻松实现上下级关系的组件之间的数据传输。它的机制与React的context类似。</p>
<p>上级组件通过<code>provide</code>配置暴露其指定名称的数据，下级组件通过<code>inject</code>配置注入其同名数据。由于<code>provide</code>配置支持函数类型，所以甚至可以将上级组件自己的引用传给下级组件。</p>
<p><code>provide</code>与<code>inject</code>配置相对隐晦，且名称容易冲突。所以一般只用在组件开发中使用，不建议在业务逻辑开发中使用。</p>
<p>如果浏览器支持ES6（<code>Symbol</code>和<code>Reflect.ownKeys</code>），那么可以使用<code>Symbol</code>作为名称来避免冲突。</p>
</div><div class="rule-code"><pre class="hljs"><code><span class="hljs-keyword">var</span> Ancestor = {
    provide() {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">specialAncestor</span>: <span class="hljs-keyword">this</span>
        };
    },
    <span class="hljs-comment">// ...</span>
};

<span class="hljs-keyword">var</span> Child = {
    <span class="hljs-attr">inject</span>: [specialAncestor],
    created() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.specialAncestor);
    }
};
</code></pre>
                        
                
</div></div></div>
<h3 id="-2">非父子组件的数据传输</h3>
<div class="rule rule-nocode rule-17">
                        <div class="rule-txt"><p>之前两条tips中已经提到了有上下级关系的组件之间的数据传输，那么如果是兄弟组件呢？这种情况下由于没有上下级关系，所以不能通过属性、事件或者<code>provide &amp;&amp; inject</code>来传输数据。</p>
<p>一般有两种方法来解决非上下级关系的组件之间的数据传输。第一种是使用组件共同的祖先组件来实现数据共享。还有一种方法是使用类似<a href="https://facebook.github.io/flux/">Flux</a>的架构来管理和实现全局的<code>store</code>。例如<a href="https://github.com/vuejs/vuex">Vuex</a>是一个不错的选择。</p>
<p><a href="https://vuejs.org/v2/guide/state-management.html#Official-Flux-Like-Implementation"><img src="./static/state.png" alt="" width="600"></a></p>
</div></div>
<h3 id="scopedslot">嵌套组件之scopedSlot传递</h3>
<div class="rule rule-18">
                        <div class="rule-right">
                        <div class="rule-txt"><p>使用scoped slot能在插槽里自定义模板并且在模板中使用组件传递过来的context。但是在组件开发的过程我们往往会在大组件中嵌套使用小组件，这样就存在把最外层的scoped slot层层传递到最内层的的情况（n &gt;= 2）。</p>
<p>那么问题来了，在文档中并没有找到使用template方式传递scoped slot的介绍和例子。但是我们找到这句话：“ Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。” 于是我们可以把scoped slot作为createElement方法的第二参数（data object）的一个属性传递到子组件中。</p>
<p>// Scoped slots in the form of
// { name: props =&gt; VNode | Array<VNode> }
scopedSlots: {
default: props =&gt; h('span', props.text)
},</p>
<p>只是render函数的缺点是不灵活，特别是在定义你的组件的dom结构模板的时候，如果写很多 render 函数，可能会觉得痛苦。它比较适用于外层组件仅仅是对内层组件的一次逻辑封装，而渲染的模板结构变化扩展不多的情况。</p>
<p>还好我们还有最后一把杀手锏--JSX。它可以让我们回到于更接近模板的语法上。
举一个栗子，我们要开发一个下拉选择组件（select），其中下来出来的列表（select-list）是一个子组件（它可以被应用到其他组件中）。
而列表的每一行被select-list组件作为了scoped slot，这样用户就能自定义这个列表的每一行如何组织长什么样。简化的template（代码片段1）：</p>
<p>然后在写select组件时我们通过JSX在其render函数中这样定义模板（代码片段2）：</p>
<p>关键点：</p>
<ul>
<li>在子组件的标签上通过<code>scopedSlots</code>属性可以向其传递自己的scoped slot；</li>
<li>自身的scoped slot可以通过<code>this.$scopedSlots</code>对象获取，默认就是default，具名slot就是它的名字。本例为<code>listItem</code>；</li>
<li>如果不在标签上传递而是需要使用表达式传递，也可以通过<code>this.$scopedSlots</code>对象。并且一个具体的scoped slot对象其实就是一个函数，其内部的scope可以在参数中传入。比如本例中的<code>this.$scopedSlots.headItem(this.current)</code></li>
</ul>
<p>与普通template的不同</p>
<ul>
<li>directives 参见本例代码</li>
<li>v-model 通过value属性传递值，并通过绑定input事件来响应变化。</li>
<li>v-if、v-for 本例中使用三目表达式来实现v-if</li>
</ul>
<p>这就是深入底层要付出的,尽管麻烦了一些，但你可以更灵活地控制。</p>
</div><div class="rule-code"><pre class="hljs"><code>&lt;!--代码片段<span class="hljs-number">1</span>:--&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in options"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">"item"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ item.text }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>

&lt;!--代码片段<span class="hljs-number">2</span>:--&gt;
&lt;script&gt;
render(h) {
    let directives = [{
        name: 'popper',
        arg: 'selector',
        modifiers: {click: true}
    }];

    return (
        &lt;div
            class={this.calcClazz}&gt;
            &lt;v-popper&gt;
                &lt;v-select-list
                    options={this.options}
                    index={this.currentIndex}
                    value={this.currentValue}
                    onInput={this.handleListInput}
                    scopedSlots={{item: this.$scopedSlots.item}} &gt;
                &lt;/v-select-list&gt;
            &lt;/v-popper&gt;
            &lt;div
                class="v-select__header"
                { ...{directives} }&gt;
                {
                    this.$scopedSlots.header
                        ? this.$scopedSlots.header({item: this.current})
                        : (&lt;span&gt;{this.placeholder}&lt;/span&gt;)
                }
                &lt;v-icon
                    class="v-select__header-arrow"
                    name="v-arrow_dropdown"&gt;
                &lt;/v-icon&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
&lt;/script&gt;
</code></pre>
                        
                
</div></div></div>
</div>
        </div>
        <script src="./static/doc.js"></script>
    </body>
    </html>